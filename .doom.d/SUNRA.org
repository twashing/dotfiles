#+PROPERTY: header-args :tangle sunra.el

* Table of Contents
:PROPERTIES:
:TOC:      :include all :depth 3
:END:
:CONTENTS:
- [[#table-of-contents][Table of Contents]]
  - [[#reference][Reference]]
    - [[#eval-expressions-in-minibuffer][Eval expressions in minibuffer]]
    - [[#disable-whitespace-mode][Disable whitespace-mode]]
      - [[#disable-doom-highlight-non-default-indentation-h][Disable doom-highlight-non-default-indentation-h]]
      - [[#disable-doom-first-buffer-hook][Disable doom-first-buffer-hook]]
      - [[#disable-whitespace-globally][Disable whitespace globally]]
    - [[#kill-groups-of-buffers][Kill groups of buffers]]
    - [[#index-of-buffer-positions][Index of buffer positions]]
    - [[#replace-across-files-grep-wgrep-mode][Replace across files, grep, wgrep mode]]
    - [[#changes-across-files][Changes across files]]
  - [[#general][General]]
    - [[#table-of-contents][Table Of Contents]]
    - [[#keybindings][Keybindings]]
    - [[#miscellaneous-configuration][Miscellaneous configuration]]
    - [[#use-org-mode-for-all-files-ending-with-notes][Use Org Mode for all files ending with .notes.]]
    - [[#general-navigation-and-text-actions][General Navigation and text actions.]]
    - [[#protesilaossubstitute][Protesilaos/Substitute]]
    - [[#free-keys][Free Keys]]
  - [[#avy][Avy]]
  - [[#navigation][Navigation]]
  - [[#smartparens-navigation][Smartparens Navigation]]
  - [[#multiple-cursors][Multiple cursors]]
  - [[#hide-show][Hide-Show]]
  - [[#cider][Cider]]
  - [[#miscellaneous][Miscellaneous]]
  - [[#copy-functions][Copy Functions]]
  - [[#completions][Completions]]
    - [[#context][Context]]
    - [[#research][Research]]
    - [[#outcome][Outcome]]
      - [[#a-these-are-the-packages-i-settled-on][A. These are the packages I settled on.]]
      - [[#b-lo-and-behold-these-are-most-of-the-choices-that-doom-makes-in-its-completionvertico-module][B. Lo and behold, these are most of the choices that Doom makes in its `completion/vertico` module.]]
      - [[#capfs][CAPFs]]
      - [[#consult][Consult]]
      - [[#embark-consult][Embark Consult]]
  - [[#denote-org-roam-replacement][Denote (Org-Roam replacement)]]
    - [[#oldarchive-org-roam][OLD:ARCHIVE: Org-Roam]]
  - [[#chatgpt][ChatGPT]]
  - [[#private-sunra-config][Private Sunra Config]]
  - [[#emacs-client][Emacs Client]]
  - [[#miscellaneous][Miscellaneous]]
    - [[#define-persistent-link-in-org][Define persistent link in Org]]
    - [[#configuration-org-insert-structure-template][Configuration: org-insert-structure-template]]
    - [[#outlining-structured-files][Outlining Structured Files]]
    - [[#embark-keymap-configuration][Embark Keymap Configuration]]
    - [[#insert-text-in-read-only-buffers][Insert Text in read-only Buffers]]
    - [[#emacs-window-management][Emacs Window Management]]
  - [[#todos][TODOs]]
    - [[#org-roam-existing-notes][Org-Roam Existing Notes]]
    - [[#configure-completion][Configure Completion]]
    - [[#consult-search-ignore-case][Consult search, ignore case]]
    - [[#navigate-mark-ring][Navigate Mark Ring]]
    - [[#master-keymaps][Master Keymaps]]
    - [[#misc][Misc]]
    - [[#org-journaling][Org Journaling]]
    - [[#org-presenting][Org Presenting]]
    - [[#spellcheck-tools-and-completions][Spellcheck Tools and Completions]]
  - [[#errors][Errors]]
    - [[#org-roam-insert-doesnt-find-new-notes][`org-roam-insert` doesn't find new notes]]
    - [[#ripgrep-is-missing-from-path][Ripgrep is missing from path]]
    - [[#hydra-mcmark-next-line-double-marks-cursor][Hydra mc/mark-next-line double marks cursor]]
    - [[#smartparens-open-square-bracket-fails-to-add-closing-bracket-when-touched-by-a-character][smartparens open square bracket fails to add closing bracket, when touched by a character]]
:END:

# NOTE preserve line breaks
# https://emacs.stackexchange.com/questions/21556/org-mode-export-how-to-force-newline-on-lines-between-paragraphs
#+OPTIONS: \n:t

** Reference

*** References

The Emacs Package Developer’s Handbook.
https://github.com/alphapapa/emacs-package-dev-handbook

Awesome Elisp. A curated list of Emacs Lisp development resources.
https://github.com/emacs-tw/awesome-elisp


*** Eval expressions in minibuffer

Show minibuffer to eval expressions.

#+BEGIN_EXAMPLE
M-:
#+END_EXAMPLE


*** Howto replace a character with a newline

StackOverflow: How can I replace a character with a newline in Emacs?
https://stackoverflow.com/questions/613022/how-can-i-replace-a-character-with-a-newline-in-emacs/613029#613029

~C-q C-j~
- C-q for quoted-insert
- C-j is a newline


*** Disable whitespace-mode

**** Disable =doom-highlight-non-default-indentation-h=

Highlight + Indent seems to be enabled when entering a new file / major mode. =doom-highlight-non-default-indentation-h= "Highlight whitespace at odds with `indent-tabs-mode'".

By using =remove-hook= the intent here is to remove whitespace-mode, which doom has disabled by default.

#+BEGIN_SRC elisp
(remove-hook 'after-change-major-mode-hook
             #'doom-highlight-non-default-indentation-h)
#+END_SRC

**** Disable =doom-first-buffer-hook=

=doom-first-buffer-hook= is a "Transient hooks run before the first interactively opened buffer."

Using =remove-hook= should remove the hook that enables =global-whitespace-mode= for the first buffer that is opened, ensuring that whitespace mode is never enabled, regardless of the circumstances.

#+BEGIN_SRC elisp
(remove-hook 'doom-first-buffer-hook
             #'global-whitespace-mode)
#+END_SRC

**** Disable whitespace globally

Attempting to disable whitespace in all the places.

#+BEGIN_SRC elisp
(defun sunra/do-before-after-init ()
  "Function to run before anything during Doom initialization."

  (global-whitespace-mode -1)
  (flycheck-mode -1))

(add-hook 'doom-before-modules-init-hook #'sunra/do-before-after-init)
(add-hook 'doom-after-modules-init-hook #'sunra/do-before-after-init)
#+END_SRC


*** Kill groups of buffers

Use =ibuffer= (also use w/ embark).
Follow the same pattern as dired... Mark then delete.


*** Index of buffer positions

https://protesilaos.com/codelog/2021-01-06-emacs-default-completion/

For a large structured file (.org .el etc), =consult-outline= and =consult-imenu= produce outline buffers.
This works as an index of buffer positions, that acts as a "table of contents".
=embark-occur= produces a persistent buffer.

#+BEGIN_EXAMPLE
consult-outline
consult-imenu
embark-occur
#+END_EXAMPLE

#+BEGIN_SRC elisp
(map! :map general-override-mode-map
      "M-m s o" #'consult-outline)
#+END_SRC


outline-minor-mode let's you define outline regex as a heading.
The variable outline-regexp can be changed to control what is a heading.
A line is a heading if outline-regexp matches something at the
beginning of the line. The longer the match, the deeper the level.

#+BEGIN_EXAMPLE
outline-minor-mode ;; Let's you define outline regex as a heading
outline-regexp
#+END_EXAMPLE


*** Replace across files, grep, wgrep mode

Search w/ grep (results must be on one line)

#+BEGIN_EXAMPLE
grep
projectile-grep
grep-find  # Perform rgrep in the project.
find-grep
find-grep-dired  # Find output is put into dired buffer
#+END_EXAMPLE

Replace + Write changes of multiple matches
C-c C-c (commit change)

#+BEGIN_EXAMPLE
wgrep-change-to-wgrep-mode     Change to wgrep mode.
wgrep-save-all-buffers         Save the buffers that wgrep changed.
wgrep-finish-edit           (C-x C-s)    Apply changes to file buffers.
wgrep-exit                  (C-x C-q)    Return to original mode.
wgrep-abort-changes            Discard all changes and return to original mo…
wgrep-mark-deletion            Mark as delete to current line.
wgrep-remove-change         (C-c C-r)    Remove changes in the region between BEG and …
wgrep-remove-all-change        Remove changes in the whole buffer.
wgrep-toggle-readonly-area     Toggle read-only area to remove a whole line.
#+END_EXAMPLE


*** Changes across files

Keyboard macros let us make multi-line changes across files.

#+BEGIN_EXAMPLE
kmacro-start-macro-or-insert-counter  # <f3>
kmacro-end-or-call-macro  # <f4>
kmacro-ring
desktop-save-mode  # saves keyboard macros, registers, any variable
#+END_EXAMPLE

Recreates variables at startup (including buffers, frames, registers...).

#+BEGIN_SRC elisp
(desktop-save-mode 1)

(add-to-list 'desktop-globals-to-save 'log-edit-comment-ring)
(add-to-list 'desktop-globals-to-save 'kmacro-ring)
(add-to-list 'desktop-globals-to-save 'kill-ring)
#+END_SRC



*** Emacs Thought Leaders

Karthink

https://github.com/karthink?tab=repositories&q=&type=&language=&sort=stargazers
https://www.youtube.com/@karthink/videos

Protesilaos

https://github.com/protesilaos
https://www.youtube.com/c/ProtesilaosStavrou
https://protesilaos.com/
https://protesilaos.com/emacs/dotemacs

Andrew Tropin

https://www.youtube.com/playlist?list=PLZmotIJq3yOKmJP_qTozdJ45hnOlOWWC5



** General

*** Table Of Contents

Using [[https://github.com/alphapapa/org-make-toc][alphapapa/org-make-toc]] for automatic Tables of Contents for Org-mode files.
Usage instructions [[https://github.com/alphapapa/org-make-toc?tab=readme-ov-file#usage][are here]].

#+BEGIN_SRC elisp

;; (use-package! org-make-toc
;;   :ensure t)

#+END_SRC


*** Keybindings


Elisp

# TODO, clashing with multiple cursors

#+BEGIN_SRC elisp
(map! :map general-override-mode-map
      "C-c l e m" #'pp-macro-expand-last-expression
      "C-c l e D" #'eval-defun-at-point)
#+END_SRC


Embark

#+BEGIN_SRC elisp
;; (map! :map general-override-mode-map
;;       "C-M a" #'embark-act
;;       "C-M e" #'embark-export
;;       "C-M c" #'embark-collect)
#+END_SRC


Marks

=consult-global-mark= lets you cycle through the mark ring.

#+BEGIN_SRC elisp
(map! :map general-override-mode-map
      "C-x <up>" #'pop-global-mark
      "C-x <down>" #'consult-global-mark)
#+END_SRC


Eshell

# TODO, not overriding default keybindings

#+BEGIN_SRC pelisp
;; (map! :map general-override-mode-map
;;       "C-c o e" #'+eshell/here
;;       "C-c o E" #'+eshell/toggle)
#+END_SRC


Append to ...

#+BEGIN_SRC elisp
(map! :map general-override-mode-map
      "C-M-<" #'append-to-buffer)
#+END_SRC


GPTel

#+BEGIN_EXAMPLE elisp
gptel-send ;; (C-c RET in gptel-mode)
#+END_EXAMPLE


Avy

#+BEGIN_SRC elisp
(map! :map general-override-mode-map
      "C->" #'avy-goto-char-timer
      "C-M->" #'avy-goto-char-2)
#+END_SRC

Version Control
#+BEGIN_EXAMPLE elisp
vc-region-history  ;; C-x v h
#+END_EXAMPLE

# TODO, play around with these configs
# diff-refine-hunk
# magit-diff-toggle-refine-hunk


*** Miscellaneous configuration


#+BEGIN_EXAMPLE elisp
kill-whole-line  ;; C-S-<backspace>
#+END_EXAMPLE


#+BEGIN_SRC elisp
(setq

 ;; Set *scratch* buffer to lisp-interaction-mode
 ;; https://emacsredux.com/blog/2014/07/25/configure-the-scratch-buffers-mode/
 ;; https://emacs.stackexchange.com/questions/3830/why-does-lisp-interaction-mode-exist-and-do-we-ever-need-it
 initial-major-mode 'lisp-interaction-mode


 ;; If you use `org' and don't want your org files in the default location below,
 ;; change `org-directory'. It must be set before org loads!
 org-directory "~/org/"

 ;; This determines the style of line numbers in effect. If set to `nil', line
 ;; numbers are disabled. For relative line numbers, set this to `relative'.
 display-line-numbers-type t

 ;; Start from 1 when inserting numbers
 mc/insert-numbers-default 1

 ;; "confirm-kill-emacs is non-nil by default. The doom-quit module only adds silly confirmation messages to it. Do this to completely disable it."
 ;; https://github.com/doomemacs/doomemacs/issues/2688#issuecomment-596684817
 confirm-kill-emacs nil

 ;; Disable auto-comment on `newline-and-indent`
 ;; https://discord.com/channels/406534637242810369/1038583508140048425
 +default-want-RET-continue-comments nil
 +evil-want-o/O-to-continue-comments nil

 ;; When minibuffer offers tab completion, make that case-insensitive
 ;; https://emacs.stackexchange.com/a/32408/10528
 completion-ignore-case t)

(flycheck-mode -1)
#+END_SRC

#+RESULTS:


*** Use Org Mode for all files ending with .notes.

#+BEGIN_SRC elisp
(add-to-list 'auto-mode-alist '("\\.notes\\'" . org-mode))
#+END_SRC


*** General Navigation and text actions.

#+BEGIN_SRC elisp
(global-set-key (kbd "C-c C-s") 'save-buffer)

(map! :map global-map
      "M-<backspace>" #'sp-backward-kill-word
      "C-c C-k" #'eval-buffer
      "C-c M-c" #'upcase-word
      "C-x M-x" #'isearch-forward-symbol-at-point
      "C-x RET" #'magit-status
      "M-W" #'delete-trailing-whitespace
      "C-/" #'org-cycle-global)

(map! :map general-override-mode-map
      "M-m p p" #'projectile-switch-project
      "M-m p f" #'projectile-find-file
      "M-m p r" #'projectile-replace
      "M-m p R" #'projectile-replace-regexp
      "M-m p S" #'projectile-save-project-buffers)
#+END_SRC


*** Protesilaos/Substitute

Source and config taken from here.
- https://github.com/protesilaos/substitute
- https://protesilaos.com/emacs/substitute

#+BEGIN_SRC elisp
(use-package! substitute
  :config

  ;; If you want a message reporting the matches that changed in the
  ;; given context.  We don't do it by default.
  (add-hook 'substitute-post-replace-functions #'substitute-report-operation)

  ;; We do not bind any keys.  This is just an idea.  The mnemonic is
  ;; that M-# (or M-S-3) is close to M-% (or M-S-5).
  (let ((map global-map))
    (define-key map (kbd "M-# s") #'substitute-target-below-point)
    (define-key map (kbd "M-# r") #'substitute-target-above-point)
    (define-key map (kbd "M-# d") #'substitute-target-in-defun)
    (define-key map (kbd "M-# b") #'substitute-target-in-buffer)))
#+END_SRC


*** Free Keys

#+BEGIN_SRC elisp

(use-package! free-keys)

#+END_SRC


** Avy

#+BEGIN_SRC elisp
(setq avy-all-windows 'all-frames)
(map! "C-c g c" #'avy-goto-char-2)
#+END_SRC


** Navigation

#+BEGIN_SRC elisp
(fset 'buf-move-up "\C-u10\C-p")
(fset 'buf-move-down "\C-u10\C-n")
(map! "M-U" #'buf-move-up
      "M-D" #'buf-move-down
      "C-d" #'sp-kill-sexp)

#+END_SRC


** Smartparens Navigation

#+BEGIN_SRC elisp
(after! smartparens
  (turn-on-smartparens-strict-mode)
  (sp-pair "(" nil :unless '(:rem sp-point-before-word-p))
  (sp-pair "{" nil :unless '(:rem sp-point-before-word-p))
  (sp-pair "[" nil :unless '(:rem sp-point-before-word-p)))

(map! :map smartparens-mode-map
      :after smartparens
      "C-M-k" #'sp-copy-sexp
      "C-M-u" #'sp-up-sexp
      "M-u" #'sp-backward-up-sexp
      "C-M-d" #'sp-down-sexp
      "M-d" #'sp-backward-down-sexp
      "C-M-j" #'sp-forward-slurp-sexp
      "C-x C-M-j" #'sp-forward-barf-sexp
      "C-M-y" #'sp-backward-slurp-sexp
      "C-x C-M-y" #'sp-backward-barf-sexp
      "C-M-n" #'sp-next-sexp
      "M-r" #'sp-raise-sexp
      "DEL" #'sp-backward-delete-char)

(after! ace-window

  ;; Switch window letter SIZE
  (custom-set-faces
   '(aw-leading-char-face
     ((t (:inherit ace-jump-face-foreground :height 6.0)))))

  ;; Ensure ace-window works across frames.
  (setq aw-scope 'global))

(map! "M-[" #'ace-select-window
      "C-c M-[" #'ace-swap-window
      "C-x M-[" #'ace-delete-window
      ;; "M-y" #'browse-kill-ring
      "C-M-[" #'scroll-other-window-down
      "C-M-]" #'scroll-other-window
      "C-M-s" #'sp-splice-sexp
      "C-M-l" #'transpose-lines)
#+END_SRC


** Multiple cursors

Mark next and previous key bindings.

Also using Emacs built-in =repeat= fn instead =repeat-mode= or =hydra=

#+BEGIN_SRC elisp
(map! "C-c m N l" #'mc/mark-next-lines
      "C-c m N t" #'mc/mark-next-like-this
      "C-c m N w" #'mc/mark-next-like-this-word
      "C-c m N W" #'mc/mark-next-word-like-this
      "C-c m N s" #'mc/mark-next-like-this-symbol
      "C-c m N S" #'mc/mark-next-symbol-like-this
      "C-c m P l" #'mc/mark-previous-lines

      "C-c s n" #'mc/skip-to-next-like-this
      "C-c s p" #'mc/skip-to-previous-like-this
      "C-c m i n" #'mc/insert-numbers

      "C-c m a t" #'mc/mark-all-like-this
      "C-c m a w" #'mc/mark-all-words-like-this
      "C-c m a s" #'mc/mark-all-symbols-like-this
      "C-c m a r" #'mc/mark-all-in-region
      "C-c m a x" #'mc/mark-all-in-region-regexp
      "C-c m a d" #'mc/mark-all-like-this-dwim
      "C-c m a D" #'mc/mark-all-dwim

      "C-c m e l" #'mc/edit-lines
      "C-c m e b" #'mc/edit-beginnings-of-lines
      "C-c m e e" #'mc/edit-ends-of-lines)

(map! "C-z" #'repeat)
#+END_SRC


** Hide-Show

#+BEGIN_SRC elisp
(map! "C-o" #'hs-toggle-hiding
      "C-c @ C-M-h" #'hs-hide-all
      "C-c @ C-M-s" #'hs-show-all
      "C-c @ C-M-l" #'hs-hide-level
      "C-M-," #'hs-hide-all
      "C-M-." #'hs-show-all
      "C-M-/" #'hs-hide-level)
#+END_SRC


** Cider

We have to clear out `C-c M-c` before we can rebind it.

#+BEGIN_SRC elisp
(after! cider

  ;; DONT open new window on cider-connect, et al
  (setq cider-repl-pop-to-buffer-on-connect nil)
  (setq cider-auto-select-test-report-buffer nil)
  (setq cider-auto-select-error-buffer nil)
  (setq cider-show-error-buffer nil))
#+END_SRC


# A

There was an issue where in clojure-mode, the key bindings I set in my Doom configuration were not taking hold.
Specifically the ~"C-c M-c" #'cider-connect-clj~ binding did not take hold in a ~.clj~ file.
Instead the ~"C-c M-c" #'upcase-word~ binding was applied from the ~global-map~.


According to "Anthropic/Claude" The issue is due to key binding precedence. The global-map binding was taking precedence over the mode-specific binding.
To fix this, I had to either:

1. Remove the global binding, or
2. Use a higher precedence map like ~general-override-mode-map~

#+BEGIN_EXAMPLE elisp

;; Remove the global binding
(map! :map global-map
      "C-c C-k" #'eval-buffer
      ;; "C-c M-c" #'upcase-word  ;; Remove this line
      "C-x M-x" #'isearch-forward-symbol-at-point)

;; Use override map for Clojure bindings
(map! :map general-override-mode-map
      :after clojure
      "C-c M-c" #'cider-connect-clj)
#+END_EXAMPLE

This fixed the problem and enfoced the Clojure-specific binding to take precedence.


# B

So the key binding precedence from highest to lowest is:

1. ~general-override-mode-map~
2. Minor mode maps
3. Local mode maps (like ~clojure-mode-map~)
4. ~global-map~

For context-specific bindings, you should:
1. Define the default in ~global-map~
2. Override in specific mode maps
3. Use ~general-override-mode-map~ only when other approaches fail

Example:

#+BEGIN_EXAMPLE elisp

;; Global default
(map! :map global-map
      "C-c M-c" #'upcase-word)

;; Mode-specific override
(map! :after clojure
      :map clojure-mode-map
      "C-c M-c" #'cider-connect-clj)
#+END_EXAMPLE


This pattern allows for contextual overrides while maintaining a default behavior.


# C

In this specific case however, this pattern failed. I was forced to use the ~general-override-mode-map~ (~a.~) in this case however, instead of the more gneneral form (~b.~).

#+BEGIN_EXAMPLE elisp

;; a.
(map! :after clojure
      :map general-override-mode-map
      "C-c M-c" #'cider-connect-clj)

;; b.
(map! :after clojure
      :map clojure-mode-map
      "C-c M-c" #'cider-connect-clj)
#+END_EXAMPLE


This specific case is unusual because ~C-c M-c~ is in the ~C-c~ prefix map, which has special handling in Emacs.
The standard pattern of mode-map override isn't working because:

1. ~C-c~ prefix keys are "reserved for users" by convention
2. The global binding is being installed in a way that makes it harder to override
3. Doom's key binding system (which uses ~general.el~) might be affecting the normal precedence rules (https://github.com/noctuid/general.el).

Using ~general-override-mode-map~ is a "force override" solution that bypasses these complications.
It's not the ideal pattern, but necessary in cases where normal mode-map precedence isn't sufficient.

If you want to verify this, I checked the effective keymap precedence with ~C-h k C-c M-c~ in a Clojure buffer.


#+BEGIN_SRC elisp
(map! :after cider
      :map general-override-mode-map
      "C-c M-c" #'cider-connect-clj
      "C-c C-k" #'cider-eval-buffer)

(map! :after clojure
      :map general-override-mode-map
      "C-c M-c" #'cider-connect-clj)

(with-eval-after-load 'general
  (define-key general-override-mode-map (kbd "C-c M-c") nil))
#+END_SRC


** Miscellaneous


#+BEGIN_SRC elisp
(defun delete-whitespace-except-one ()
  (interactive)
  (just-one-space -1))

(map! "C-M-SPC" #'delete-whitespace-except-one
      "C-," #'+default/newline-above
      "C-." #'+default/newline-below)

#+END_SRC


** Copy Functions

Copy line

#+BEGIN_SRC elisp
(defun copy-line (&optional arg)
  "Do a kill-line but copy rather than kill.  This function directly calls
  kill-line, so see documentation of kill-line for how to use it including prefix
  argument and relevant variables.  This function works by temporarily making the
  buffer read-only."
  (interactive "P")
  (let ((buffer-read-only t)
        (kill-read-only-ok t))
    (kill-line arg)))

(map! "C-c k" #'copy-line
      "C-c K" #'avy-copy-line)

#+END_SRC

Copy a random region, at any remote location in the frame.

Works with a narrowed (single) avy selection, capturing the beginning of the first selection, and end of the second selection.

Also works, prompting the user to select from a choice of avy candidates.

#+BEGIN_SRC elisp

(require 'cl-lib)

(defun zipmap (keys values)
  (cl-pairlis keys values))

(defun sunra/avy-read-process-window-in-list (list)
  (mapcar
   (lambda (triplet)
     (let ((first (nth 0 triplet))
           (last (nth 2 triplet))
           line-number
           substring
           buffer
           selection-candidate)

       (save-window-excursion
         (select-window last)
         (goto-char first)

         (setq line-number (line-number-at-pos))
         (setq substring (buffer-substring-no-properties first (nth 1 triplet)))
         (setq buffer (window-buffer last))
         (setq selection-candidate (format "%d %s %s" line-number substring buffer)))

       (list selection-candidate line-number substring buffer)))
   list))

(defun sunra/avy-read-candidates-prompt (candidates)

  (let* ((cans (sunra/avy-read-process-window-in-list candidates))
         (hashes (mapcar (lambda (c)
                           (secure-hash 'sha1 (car c)))
                         cans))
         (cadidates-selections-hash (zipmap hashes candidates))

         ;; Take selection, get hash, compare
         (the-selection (completing-read "Select a match: " (mapcar #'car cans)))
         (the-selection-hash (secure-hash 'sha1 the-selection)))

    (alist-get the-selection-hash cadidates-selections-hash nil nil #'string=)))

(defun sunra/avy-read-candidates-return ()

  ;; Read candidates from User prompt
  (let* ((candidates (avy--read-candidates))
         (flat-cands (mapcar #'flatten-list candidates)))

    ;; Conditionally narrow candidates if many, or select the one
    (if (> (length flat-cands) 1)
       (sunra/avy-read-candidates-prompt flat-cands)
      (car flat-cands))))

(defun sunra/copy-remote-region ()
  (interactive)

  ;; Make avy wait a (practically) infinate amount of time
  (let ((avy-timeout-seconds most-positive-fixnum))

    (let* ((triplet-start (sunra/avy-read-candidates-return))
           (candidate-start-position-start (nth 0 triplet-start))
           (window (nth 2 triplet-start))

           (triplet-end (sunra/avy-read-candidates-return))
           (candidate-end-position-end (nth 1 triplet-end)))

      (save-window-excursion

        (select-window window)

        (kill-new
         (buffer-substring-no-properties
          candidate-start-position-start
          candidate-end-position-end))))))

#+END_SRC


** Completions

*** Context

Exploring the optimal Emacs Completions with

#+BEGIN_EXAMPLE
Vertigo
vs Helm
vs Counsel (used in Doom)
vs Consult (improvement over counsel? - https://github.com/minad/consult)
#+END_EXAMPLE

Using Emacs Episode 80 - Vertico, Marginalia, Consult, and Embark
- https://www.youtube.com/watch?v=5ffb2at2d7w

Streamline Your Emacs Completions with Vertico
- https://www.youtube.com/watch?v=J0OaRy85MOo
- https://systemcrafters.cc/emacs-tips/streamline-completions-with-vertico
- https://github.com/minad/vertico


*** Research

Emacs Completion Explained
- https://www.youtube.com/watch?v=fnE0lXoe7Y0

Using Emacs Episode 80 - Vertico, Marginalia, Consult, and Embark
- https://www.youtube.com/watch?v=5ffb2at2d7w
- https://cestlaz.github.io/post/using-emacs-80-vertico

Emacs: completion framework (Embark, Consult, Orderless, etc.)
- https://www.youtube.com/watch?v=43Dg5zYPHTU
- https://protesilaos.com/codelog/2021-01-06-emacs-default-completion


"One important feature is that it plugs in directly to Emacs' own completion engine unlike Helm and Ivy which have their own layer on top."
- https://systemcrafters.cc/emacs-tips/streamline-completions-with-vertico

[no] Helm, Ivy, have been superceded

[ok] Annotations exist on command execution and help menus. Addition not needed.
- Marginalia - https://github.com/minad/marginalia


*** Outcome

**** A. These are the packages I settled on.

- Vertico - https://github.com/minad/vertico
  - Completion-at-point - https://github.com/minad/vertico#completion-at-point-and-completion-in-region
  - Corfu - https://github.com/minad/corfu
- Consult - https://github.com/minad/consult
- Embark - https://github.com/oantolin/embark
- Orderless (vs Prescient, Selectrum)
  - https://github.com/oantolin/orderless
  - https://github.com/radian-software/prescient.el
  - https://github.com/radian-software/selectrum


**** B. Lo and behold, these are most of the choices that Doom makes in its `completion/vertico` module.

So all I had to do was enable it: `(doom! :completion  vertico)` ([ref](https://github.com/doomemacs/doomemacs/tree/master/modules/completion/vertico)).

- Vertico, which provides the vertical completion user interface
- Consult, which provides a suite of useful commands using completing-read
- Embark, which provides a set of minibuffer actions
- Marginalia, which provides annotations to completion candidates
- Orderless, which provides better filtering methods

#+begin_src elisp
(after! vertico

  (vertico-buffer-mode)
  (setq completion-styles '(orderless basic)))

;; (use-package! corfu
;;
;;   ;; Optional customizations
;;   :custom
;;   (corfu-cycle t)                ;; Enable cycling for `corfu-next/previous'
;;   (corfu-auto t)                 ;; Enable auto completion
;;   (corfu-separator ?\s)          ;; Orderless field separator
;;   (corfu-quit-at-boundary nil)   ;; Never quit at completion boundary
;;   (corfu-quit-no-match nil)      ;; Never quit, even if there is no match
;;   ;; (corfu-preview-current nil)    ;; Disable current candidate preview
;;   ;; (corfu-preselect-first nil)    ;; Disable candidate preselection
;;   ;; (corfu-on-exact-match nil)     ;; Configure handling of exact matches
;;   ;; (corfu-echo-documentation nil) ;; Disable documentation in the echo area
;;   ;; (corfu-scroll-margin 5)        ;; Use scroll margin
;;
;;   ;; Enable Corfu only for certain modes.
;;   :hook ((prog-mode . corfu-mode)
;;          (org-mode . corfu-mode)
;;          (shell-mode . corfu-mode)
;;          (eshell-mode . corfu-mode))
;;
;;   ;; Recommended: Enable Corfu globally.
;;   ;; This is recommended since Dabbrev can be used globally (M-/).
;;   ;; See also `corfu-excluded-modes'.
;;   :init
;;   (global-corfu-mode))

;; A few more useful configurations...
(use-package! emacs
  :init
  ;; TAB cycle if there are only few candidates
  (setq completion-cycle-threshold 3)

  ;; Emacs 28: Hide commands in M-x which do not apply to the current mode.
  ;; Corfu commands are hidden, since they are not supposed to be used via M-x.
  ;; (setq read-extended-command-predicate
  ;;       #'command-completion-default-include-p)

  ;; Enable indentation+completion using the TAB key.
  ;; `completion-at-point' is often bound to M-TAB.
  (setq tab-always-indent 'complete))
#+END_SRC


**** CAPFs

#+BEGIN_QUOTE
Completions are either provided by commands like dabbrev-completion or by pluggable backends (completion-at-point-functions, Capfs).

Most programming language major modes implement a Capf. Furthermore the language server packages, Eglot and Lsp-mode, use Capfs which talk to the LSP server to retrieve the completions.

Corfu does not include its own completion backends.
The Emacs built-in Capfs and the Capfs provided by other programming language packages are usually sufficient.

A few additional Capfs and completion utilities are provided by the Cape package.
#+END_QUOTE


From this blurb taken from the [[https://github.com/minad/corfu#corfuel---completion-overlay-region-function][corfu.el repo]], I'm settling on these `completion-aat-point-functions`.

- [[https://github.com/minad/cape][Cape]] - Completion At Point Extensions
- [[https://github.com/joaotavora/eglot][Eglot]] - A client for LSP servers

Initial config stolen from this thread.
- [[https://git.sr.ht/~gagbo/doom-config/tree/master/item/modules/completion/corfu][B]]
- [[https://github.com/doomemacs/doomemacs/issues/5600][A]]

#+BEGIN_SRC elisp

(use-package! cape
  :defer t
  :init
  (map! [remap dabbrev-expand] 'cape-dabbrev)
  (add-to-list 'completion-at-point-functions #'cape-file)
  (add-to-list 'completion-at-point-functions #'cape-dabbrev t))


;; (use-package! corfu-history
;;   :after corfu
;;   :hook (corfu-mode . (lambda ()
;;                         (corfu-history-mode 1)
;;                         (savehist-mode 1)
;;                         (add-to-list 'savehist-additional-variables 'corfu-history))))

(use-package! corfu-quick
  ;; :after corfu
  :bind (:map corfu-map
         ("M-q" . corfu-quick-complete)
         ("C-q" . corfu-quick-insert)))

#+END_SRC

And Flymake configs for Eglot.

#+BEGIN_SRC elisp
;; (use-package! flymake
;;   :config
;;   (setq flymake-start-on-flymake-mode t)
;;   (setq flymake-no-changes-timeout nil)
;;   (setq flymake-start-on-save-buffer t))
;;
;; (use-package! flymake-kondor
;;   :hook (clojure-mode . flymake-kondor-setup))
#+END_SRC


**** Consult


#+BEGIN_SRC elisp
(map! :map general-override-mode-map
      "C-x b" #'consult-buffer
      "M-m s s" #'consult-line
      "M-m s S" #'consult-line-multi
      "M-y" #'consult-yank-from-kill-ring)
#+END_SRC


**** Embark Consult

Sets up compatibility layer between the two packages.
https://elpa.gnu.org/packages/embark-consult.html

This should just work out of the box.

#+BEGIN_SRC elisp
(use-package! embark-consult)
#+END_SRC


** Denote (Org-Roam replacement)

For Knowledge Management. Document everything, making it searchable.

https://github.com/protesilaos/denote

Emacs: introduction to Denote (simple note-taking)
https://www.youtube.com/watch?v=mLzFJcLpDFI

Is migrating to denote worth it?
https://www.reddit.com/r/emacs/comments/19do7da/is_migrating_to_denote_worth_it

*** Links

In the Denote emacs package (https://github.com/protesilaos/denote),
Denote notes are in `.md` format. And a denote link (to another note) cannot also be an HTTP hyperlink. They are different constructs.

For standard Denote links to other notes in Markdown format, the syntax looks like this.
#+BEGIN_EXAMPLE
[[denote:20230815T102233][Title of note]]
#+END_EXAMPLE

And HTTP hyperlinks in Markdown use the standard Markdown syntax:
#+BEGIN_EXAMPLE
[Link text](https://example.com)
#+END_EXAMPLE

So the strategy will be to place them adjacent to each other if needed.



#+BEGIN_SRC elisp
(after! denote

  (use-package! denote
    :config
    (setq denote-directory (expand-file-name "~/Projects/notes/")
          denote-known-keywords '("emacs" "clojure" "guix")
          denote-infer-keywords t
          denote-sort-keywords t
          denote-file-type 'markdown-yaml ; Org is the default, set others here
          denote-prompts '(title keywords)
          denote-excluded-directories-regexp nil
          denote-excluded-keywords-regexp nil)))
#+END_SRC

*** OLD:ARCHIVE: Org-Roam

This is the old Org-Roam configuration, since replaced by Denote.
These are references and notes, including howto videos.

- https://www.orgroam.com/
- https://github.com/org-roam/org-roam
- https://lucidmanager.org/productivity/taking-notes-with-emacs-org-mode-and-org-roam/
[[How I Take Notes with Org-Roam][- https://jethrokuan.github.io/org-roam-guide/]]
- [[https://www.youtube.com/watch?v=rH3ZH95zjKM][Org Roam Setup · Emacs Doomcasts 25]]
- [[https://www.youtube.com/watch?v=83JoRBjTXog][Aliases in Org Roam Emacs Doom · Emacs Doomcasts 26]]
- [[https://www.youtube.com/watch?v=AyhPmypHDEw][Getting Started with Org Roam - Build a Second Brain in Emacs]]
- [[https://www.youtube.com/watch?v=3H38Yglw1dU][The Goal: Building My Second Brain with Emacs and Org-Roam (An Overview)]]

#+BEGIN_SRC elisp
;; (after! org-roam
;;
;;   (setq org-roam-directory (file-truename "~/roam"))
;;
;;   ;; add markdown extension to org-roam-file-extensions list
;;   (setq org-roam-file-extensions '("org" "md")) ; enable Org-roam for a markdown extension
;;   (setq org-roam-title-sources '((mdtitle title mdheadline headline) (mdalias alias)))
;;
;;   (add-to-list 'load-path (file-truename "~/.emacs.d/.local/straight/repos/md-roam"))
;;
;;   ;; Configs taken from the home repo
;;   ;; https://github.com/org-roam/org-roam#configuration
;;   (setq org-roam-node-display-template (concat "${title:*} " (propertize "${tags:10}" 'face 'org-tag)))
;;   )
#+END_SRC

Note: I had to manually eval `use-package md-roam`, in order to have it compile and run.
Otherwise I ran into [this error](https://discord.com/channels/406534637242810369/1028497228148518932) loading the package.

#+BEGIN_SRC elisp
;; (use-package! md-roam
;;  :config
;;
;;  ;; (setq md-roam-file-extension-single "md")
;;  (md-roam-mode 1) ; md-roam-mode must be active before org-roam-db-sync
;;  (setq md-roam-file-extension "md") ; default "md". Specify an extension such as "markdown"
;;  (org-roam-db-autosync-mode 1) ; autosync-mode triggers db-sync. md-roam-mode must be already active
;;
;;  (add-to-list 'org-roam-capture-templates
;;               '("m" "Markdown" plain "" :target
;;                 (file+head "${slug}.md"
;;                            "---\ntitle: ${title}\nid: %<%Y-%m-%dT%H%M%S>\ncategory: \n---\n")
;;                 :unnarrowed t))
;;
;;  (with-eval-after-load 'markdown-mode
;;   (advice-add #'markdown-indent-line :before-until #'completion-at-point)))
#+END_SRC


** ChatGPT



*** Overview

https://github.com/karthink/gptel?tab=readme-ov-file#gptel-a-simple-llm-client-for-emacs

`karthink/gptel` is a simple Large Language Model chat client for Emacs, with support for multiple models and backends. It works in the spirit of Emacs, available at any time and uniformly in any buffer.



*** Features

https://github.com/karthink/gptel?tab=readme-ov-file#contents

**** Rewrite a Region

https://github.com/karthink/gptel?tab=readme-ov-file#rewrite-refactor-or-fill-in-a-region

**** Tool Use

Tool use (experimental)
https://github.com/karthink/gptel?tab=readme-ov-file#tool-use-experimental

Tool use with gptel: looking for testers!
https://karthinks.com/software/tool-use-with-gptel-looking-for-testers/

Instructions for testing tool use (on gptel’s issue tracke)
https://github.com/karthink/gptel/issues/514



*** File Templating

I needed File templating like what we get in cgrande/enlive.
https://github.com/cgrand/enlive

The template DSL looks like below, where
the contents of file =Content.md= (~Bar~) and
contents of variable =thing= (~querty~), are combined with =A.md.tmpl= and output to =A.md=.

#+BEGIN_EXAMPLE
#Content.md
Bar
#+END_EXAMPLE

#+BEGIN_EXAMPLE
#A.md.tmpl
Foo {file:Content.md}
{var:thing}
#+END_EXAMPLE

#+BEGIN_EXAMPLE
#A.md
Foo Bar
querty
#+END_EXAMPLE


None of these solutions quite fit the bill.
- https://github.com/mineo/yatemplate
- https://www.emacswiki.org/emacs/TemplatesMode
- https://www.emacswiki.org/emacs/defaultcontent.el

Most of what's available in Emacs are snippet libraries like joaotavora/yasnippet or minad/tempel
- https://www.emacswiki.org/emacs/CategoryTemplates

Thus begat =apply-template= and =apply-templates=.


*** Tool Use

LLM "tools" are functions you supply to the LLM... that it can use to do work for you in the world (your file system, web, etc).
My comment in this article documents my "ah ha" moment.
https://karthinks.com/software/tool-use-with-gptel-looking-for-testers/#remark42__comment-ff369a61-5e0e-45a1-8834-fdc4a8db0e36

There are a suite of LLM "tools" in the ~gptel/tools~ directory.
But I wanted to create a tool that generates a tool (that uses `gptel-make-tool`) from an existing elisp function.
=generate_llm_tool= is a i. function and ii. LLM tool that does just that.

This tool:
1. Takes a function name and a category as input
2. Checks if the function exists and is callable
3. Extracts the function's argument list and documentation
4. Creates properly formatted argument descriptors for each parameter
5. Builds a complete gptel-make-tool definition with all the required parts
6. Returns either the tool definition or an error message

The generated tool will:
- Use the original function's name as the tool name
- Use the first line of the docstring as the tool description
- Use the function itself directly via #'function-name
- Generate simple argument descriptors based on the parameter names
- Use the provided category


*** Configuration

#+BEGIN_SRC elisp
(defun apply-template (template-file output-file &optional context)
  "Apply a template file TEMPLATE-FILE and write the result to OUTPUT-FILE.
   Replaces placeholders of the form:
   - {file:FILENAME} with the contents of FILENAME (resolved relative to TEMPLATE-FILE's directory)
   - {var:VARNAME} with the value associated with VARNAME in CONTEXT (an alist), or an empty string if CONTEXT is nil.

   Example usage:
   Assuming your project directory contains:
   - \"Content.md\" with contents: \"Bar\"
   - \"A.md.tmpl\" with contents:
        Foo {file:Content.md}
        {var:thing}

   And you want to create \"A.md\" with the inserted text.
   You can call with or without a context of variables

   (apply-template \"path/to/project-directory/A.md.tmpl\"
                   \"path/to/project-directory/A.md\"
                   '((\"thing\" . \"querty\")))

   (apply-template \"path/to/project-directory/A.md.tmpl\"
                   \"path/to/project-directory/A.md\")"

  (let ((project-dir (file-name-directory template-file)))

    (with-temp-buffer

      ;; Read template into a string.
      (insert-file-contents template-file)
      (let ((template (buffer-string)))

        ;; Replace {file:...} placeholders.
        (setq template
              (replace-regexp-in-string
               "{file:\\([^}]+\\)}"
               (lambda (match)
                 ;; Obtain the file name from the match.
                 (let* ((raw-filename (match-string 1 match))
                        ;; Remove any extraneous escape characters if needed.
                        (filename (replace-regexp-in-string "\\\\" "" raw-filename))
                        (full-path (expand-file-name filename project-dir)))
                   (with-temp-buffer
                     (condition-case err
                         (progn
                           (insert-file-contents full-path)
                           (buffer-string))
                       (error (format "[Error reading file: %s]" full-path))))))
               template t t))

        ;; Replace {var:...} placeholders.
        (setq template
              (replace-regexp-in-string
               "{var:\\([^}]+\\)}"
               (lambda (match)
                 (if (string-match "{var:\\([^}]+\\)}" match)
                     (if context
                         (or (cdr (assoc (match-string 1 match) context)) "")
                       "")
                   match))
               template t t))

        ;; Write the resulting string to OUTPUT-FILE.
        (with-temp-file output-file
          (insert template))))))

(defun apply-templates (dir &optional context)
  "Process all .tmpl files in DIR.
   For each file with a .tmpl suffix, create an output file by removing the .tmpl suffix.
   If CONTEXT (an alist) is provided, it is passed to `apply-template` for variable substitutions.

   Example usage:
   Suppose you have a directory \"path/to/project-directory\" with:
     - \"A.md.tmpl\"
     - \"main.c.tmpl\"
   And you want to process these templates with a context:

   (apply-templates \"gptel/directives\"
                    '((\"thing\" . \"querty\")))"

  (dolist (tmpl-file (directory-files dir t "\\.tmpl$"))

    (when (file-regular-p tmpl-file)
      (let* ((output-file (replace-regexp-in-string "\\.tmpl$" "" tmpl-file)))
        (apply-template tmpl-file output-file context)
        (message "Processed template: %s -> %s" tmpl-file output-file)))))

(defun load-gptel-directives (dir)
  "Load all directive files from DIR into gptel-directives.
   Newer directives override existing ones with the same key."
  (let* ((files (directory-files dir t "\\.md$"))
         (new-pairs (mapcar (lambda (file)
                              (cons
                               (intern (file-name-base file))
                               (with-temp-buffer
                                 (insert-file-contents file)
                                 (buffer-string))))
                            files))
         (existing-keys (mapcar #'car gptel-directives))
         (filtered-old (cl-remove-if (lambda (pair)
                                       (member (car pair) (mapcar #'car new-pairs)))
                                     gptel-directives)))
    (setq gptel-directives
          (append new-pairs filtered-old))))

(defun load-all! (dir)
  "Load all .el files from DIR"
  (dolist (file (directory-files dir t "\\.el$"))
    (load! file)))

(use-package! gptel

  :bind ("C-M-'" . gptel-send)
  :config

  (load! "openapi-key.el")
  (load! "gemini-key.el")
  (load! "anthropic-key.el")
  (load! "linkup-api-key.el")

  (apply-templates (file-name-concat (dir!) "gptel/directives"))
  (load-gptel-directives (file-name-concat (dir!) "gptel/directives"))
  (load-all! (file-name-concat (dir!) "gptel/tools/"))

  (setq! gptel-api-key openapi-key
         gptel-expert-commands t
         gptel-prompt-prefix-alist '((markdown-mode . "*Prompt* ")
                                     (org-mode . "*Prompt* ")
                                     (text-mode . "*Prompt*  "))
         gptel-response-prefix-alist '((markdown-mode . "*Response* ")
                                       (org-mode . "*Response* ")
                                       (text-mode . "*Response* ")))

  ;; :key can be a function that returns the API key.
  ;; Any name you want
  ;; Streaming responses
  (gptel-make-gemini "Gemini"
    :key gemini-key
    :stream t)
  (gptel-make-anthropic "Claude"
    :key anthropic-key
    :stream t)

  ;; NOTE keep this until moving back to `main' branch
  (setq gptel--anthropic-models
        (cons '(claude-3-7-sonnet-20250219
                :description "Hybrid model capable of standard thinking and extended thinking modes"
                :capabilities (media tool-use cache)
                :mime-types ("image/jpeg" "image/png" "image/gif" "image/webp" "application/pdf")
                :context-window 200
                :input-cost 3
                :output-cost 15
                :cutoff-date "2025-02")
              gptel--anthropic-models)))

(use-package! gptel-quick

  :bind (:map embark-general-map
              ("?" . #'gptel-quick)))
#+END_SRC


** Private Sunra Config

Setting personal functions to jump to my Sunra config files.

#+BEGIN_SRC elisp

(defun sunra/goto-emacs-dir ()
  "Open my ~/.emacs.d directory."
  (interactive)
  (dired doom-emacs-dir))

(defun sunra/goto-private-config-sunra-el ()
  "Open my private config.el file."
  (interactive)
  (find-file (expand-file-name "sunra.el" doom-user-dir)))

(defun sunra/goto-private-config-sunra-org ()
  "Open my private Config.org file."
  (interactive)
  (find-file (expand-file-name "SUNRA.org" doom-user-dir)))

(let ((map global-map))
  (define-key map (kbd "C-h d e") #'sunra/goto-emacs-dir)
  (define-key map (kbd "C-h d r") #'sunra/goto-private-config-sunra-el)
  (define-key map (kbd "C-h d R") #'sunra/goto-private-config-sunra-org))
#+END_SRC

Per this Stackexchange thread, there's a mismatch between doom and emacs versions. So pinning packages for now.
https://emacs.stackexchange.com/questions/75827/doom-emacs-error-running-hook-global-git-commit-mode-because-void-variable

#+BEGIN_SRC elisp
(package! transient
      :pin "c2bdf7e12c530eb85476d3aef317eb2941ab9440"
      :recipe (:host github :repo "magit/transient"))

(package! with-editor
          :pin "bbc60f68ac190f02da8a100b6fb67cf1c27c53ab"
          :recipe (:host github :repo "magit/with-editor"))
#+END_SRC


** Screenshots and Audio / Video recording


=screenshot= is an Emacs lisp function that can
i. take a shot of desktop screen or ii. shot of an active Emacs window
using the CLI =Image Magick=, or ~screencapture~ on MacOS

Usage
#+BEGIN_EXAMPLE elisp
(screenshot)    ;; Entire desktop with all active windows
(screenshot t)  ;; Call with emacs-frame-only
#+END_EXAMPLE


#+BEGIN_SRC elisp

(require 'cl-lib)

(defun screenshot (&optional emacs-frame-only)
  "Take a screenshot and save it to a file.
With prefix argument ARG, capture the current active Emacs frame only.
Otherwise, capture the entire screen."
  (interactive "P")
  (let* ((default-directory (expand-file-name "~/Pictures/"))
         (timestamp (format-time-string "%Y%m%d-%H%M%S"))
         (file-name (concat "screenshot-" timestamp ".png"))
         (full-path (expand-file-name file-name))
         (command
          (cond
           ((eq system-type 'darwin)
            (if emacs-frame-only
                (format "screencapture -l$(osascript -e 'tell app \"Emacs\" to id of window 1') %s"
                        (shell-quote-argument full-path))
              (format "screencapture %s"
                      (shell-quote-argument full-path))))
           ((eq system-type 'gnu/linux)
            (if emacs-frame-only
                (format "ffmpeg -y -f x11grab -i 0x%s -vframes 1 %s"
                        (frame-parameter nil 'outer-window-id)
                        (shell-quote-argument full-path))
              (format "ffmpeg -y -f x11grab -i :0 -vframes 1 %s"
                      (shell-quote-argument full-path))))
           (t (error "No suitable screenshot command found for this system")))))
    (make-directory (file-name-directory full-path) t)
    (if (zerop (shell-command command))
        (progn
          (message "Screenshot saved to %s" full-path)
          (when (y-or-n-p "Open screenshot? ")
            (find-file full-path)))
      (error "Failed to take screenshot"))))


;; `screenshot` is an Emacs lisp function that can
;; i. take a shot of desktop screen or ii. shot of an active Emacs window
;; using the CLI =Image Magick=, or ~screencapture~ on MacOS
;;
;; Usage
;; ;; (setq debug-on-error t)
;; ;; (toggle-debug-on-error)

;; (screenshot)
;; (screenshot t)

(defun screencapture (screen-id &optional duration)
  "Record the screen with SCREEN-ID for DURATION seconds using ffmpeg’s avfoundation input.
   SCREEN-ID is the device index shown when running:
   ffmpeg -f avfoundation -list_devices true -i \"\"

By default, DURATION is 5 seconds.  The resulting file is placed in ~/Pictures/ with a timestamp.

On non-macOS systems, this function currently signals an error."
  (interactive "nEnter screen device index: \nnDuration in seconds (default 5): ")
  (unless duration
    (setq duration 5))

  (let* ((default-directory (expand-file-name "~/Pictures/"))
         (timestamp (format-time-string "%Y%m%d-%H%M%S"))
         (file-name (concat "screencapture-" timestamp ".mp4"))
         (full-path (expand-file-name file-name))
         ;; Construct the ffmpeg command for avfoundation
         (command (format "ffmpeg -y -f avfoundation -i %s:0 -t %s %s"
                          screen-id
                          duration
                          (shell-quote-argument full-path))))
    (make-directory (file-name-directory full-path) t)
    (if (zerop (shell-command command))
        (progn
          (message "Screen recording saved to %s" full-path))
      (error "Failed to record from screen ID %s" screen-id))))

;; Usage

;; Record the desktop from screen 3 for 10 seconds
;; (screencapture 3 10)
;;
;; Record the desktop from screen 2 for 5 seconds
;; (screencapture 2 5)

;; # ffmpeg can list out the available desktop screen devices
;; ffmpeg -f avfoundation -list_devices true -i ""
;; ...
;; [AVFoundation indev @ 0x12a804080] AVFoundation video devices:
;; [AVFoundation indev @ 0x12a804080] [0] LG UltraFine Display Camera
;; [AVFoundation indev @ 0x12a804080] [1] FaceTime HD Camera
;; [AVFoundation indev @ 0x12a804080] [2] Capture screen 0
;; [AVFoundation indev @ 0x12a804080] [3] Capture screen 1
;; [AVFoundation indev @ 0x12a804080] AVFoundation audio devices:
;; [AVFoundation indev @ 0x12a804080] [0] LG UltraFine Display Audio
;; [AVFoundation indev @ 0x12a804080] [1] MacBook Pro Microphone
;; [AVFoundation indev @ 0x12a804080] [2] Bose QC45

#+END_SRC


** Web Search

*** Task

This follows work to allow Emacs (and our LLM(s)) perform web searches.

Research and web search options are in the Jira ticket: Emacs: GPTel Search the Web
https://interruptsoftware.atlassian.net/browse/TECH-106

The currently selected option is "Linkup".

*** Tool

Linkup is "World’s best search for AI Apps"
https://www.linkup.so
https://docs.linkup.so/pages/documentation/get-started/quickstart
https://docs.linkup.so/pages/documentation/get-started/concepts

=/search= query format is here:
HTTP POST https://docs.linkup.so/pages/documentation/api-reference/endpoint/post-search

This is a sample curl call.
#+BEGIN_EXAMPLE
curl "https://api.linkup.so/v1/search" \
    -G \
    -H "Authorization: Bearer $LINKUP_API_KEY" \
    --data-urlencode "q=What is Microsoft's 2024 revenue?" \
    --data-urlencode "depth=deep" \
    --data-urlencode "outputType=sourcedAnswer"
#+END_EXAMPLE

*** Solution

The =websearch= function makes a REST call to the "Linkup" web search API. It uses Emacs' =plz= HTTP library.
https://github.com/alphapapa/plz.el

The function takes the parameters ~query~ ~linkup_api_key~ and ~depth~ and plugs them into the REST API call.

#+BEGIN_SRC elisp

(use-package! plz)

(defun websearch (query &optional api-key &optional depth)
  "Search Linkup API with QUERY using the corresponding API-KEY.
   Optional DEPTH parameter can be 'deep or 'shallow (defaults to deep).
   Returns response as parsed JSON or signals an error."
  (condition-case err
      (let* ((depth-value (or depth "deep"))
             (linkup-api-key (or api-key linkup-api-key))
             (json-object (json-encode
                           `(("q" . ,query)
                             ("depth" . ,depth-value)
                             ("outputType" . "sourcedAnswer")
                             ("includeImages" . "false"))))
             (url-request-method "POST")
             (url-request-extra-headers
              `(("Authorization" . ,(concat "Bearer " linkup-api-key))
                ("Content-Type" . "application/json")))
             (url-request-data json-object)
             (buffer (url-retrieve-synchronously
                      "https://api.linkup.so/v1/search" t)))
        (if buffer
            (with-current-buffer buffer
              (goto-char url-http-end-of-headers)
              (let ((json-response (json-read)))
                (kill-buffer buffer)
                (if (and (listp json-response) json-response)
                    json-response
                  (error "Invalid response format from Linkup API"))))
          (error "No response from Linkup API")))

    (json-error
     (error "Failed to parse Linkup API response: %s" (error-message-string err)))

    (error
     (error "Linkup search error: %s" (error-message-string err)))))

;; ;; Example usage:
;; (websearch "What is Microsoft's 2024 revenue?"
;;            "7c913f85-698f-487f-a95b-a5dc949f50f3")
;; (websearch "What is Microsoft's 2024 revenue?"
;;            "7c913f85-698f-487f-a95b-a5dc949f50f3"
;;            "deep")

#+END_SRC


** Emacs Client


[[https://www.youtube.com/watch?v=ZjCRxAMPdNc][Unlock the Power of the Daemon with emacsclient]]
Reload Doom config

emacs --daemon
emacsclient

. Setting these guys
$EDITOR=emacsclient
/Applications/Emacs.app/Contents/MacOS/Emacs --daemon
/Applications/Emacs.app/Contents/MacOS/bin/emacsclient -cn

. Created EmacsDaemon, EmacsClient as launchable apps, as per:
https://stackoverflow.com/questions/10376206/what-is-the-preferred-bash-shebang


** Miscellaneous

*** Define persistent link in Org

Define persistent link in Org.
Unique and unbreakable headings in Org files.

#+BEGIN_SRC elisp

(defun prot-org--id-get (&optional pom create prefix)
  "Get the CUSTOM_ID property of the entry at point-or-marker POM.

If POM is nil, refer to the entry at point.
If the entry does not have an CUSTOM_ID, the function returns nil. However, when
CREATE is non nil, create a CUSTOM_ID if none is present already.
PREFIX will be passed through to `org-id-new'.  In any case, the
CUSTOM_ID of the entry is returned."
  (org-with-point-at pom
    (let ((id (org-entry-get nil "CUSTOM_ID")))
      (cond
       ((and id (stringp id) (string-match "\\S-" id))
        id)
       (create
        (setq id (org-id-new (concat prefix "h")))
        (org-entry-put pom "CUSTOM_ID" id)
        (org-id-add-location id (format "%s" (buffer-file-name (buffer-base-buffer))))
        id)))))

(declare-function org-map-entries "org")

;;;###autoload
(defun prot-org-id-headlines ()
  "Add missing CUSTOM_ID to all headlines in current file."
  (interactive)
  (org-map-entries
   (lambda () (prot-org--id-get (point) t))))

#+END_SRC


*** Configuration: org-insert-structure-template

=org-insert-structure-template=
~org-insert-structure-template~

#+BEGIN_SRC elisp

(setq org-structure-template-alist
        '(("s" . "src")
          ("E" . "src emacs-lisp")
          ("e" . "example")
          ("q" . "quote")
          ("v" . "verse")
          ("V" . "verbatim")
          ("c" . "center")
          ("C" . "comment")))

#+END_SRC


*** Outlining Structured Files

Functions for outlining a structured file.

#+BEGIN_EXAMPLE elisp
consult-outline ; especially for Org
consult-imenu   ; for programming
consult-line    ; in-buffer search with previews
consult-grep    ; async+live grep with preview
consult-ripgrep ; same but for ripgrep
#+END_EXAMPLE


*** Embark Keymap Configuration

See more examples at [[https://github.com/oantolin/embark?tab=readme-ov-file#acting-on-targets][the source]].

#+BEGIN_EXAMPLE elisp

;; Old Emacs (always works)
(defvar my-embark-region-map
  (let ((map (make-sparse-keymap)))
    (define-key map (kbd "a") 'some-command)
    (define-key map (kbd "e") 'some-command)
    map)
  "My keymap for Embark region actions.")

;; For Emacs 29+
(defvar-keymap my-embark-region-map
  :doc "Some documentation"
  "a" 'some-command
  "b" 'some-other-command)


(setq embark-keymap-alist
      '((file embark-file-map)
        (library embark-library-map)
        (environment-variables embark-file-map) ; they come up in file completion
        (url embark-url-map)
        (email embark-email-map)
        (buffer embark-buffer-map)
        (tab embark-tab-map)
        (expression embark-expression-map)
        (identifier embark-identifier-map)
        (defun embark-defun-map)
        (symbol embark-symbol-map)
        (face embark-face-map)
        (command embark-command-map)
        (variable embark-variable-map)
        (function embark-function-map)
        (minor-mode embark-command-map)
        (unicode-name embark-unicode-name-map)
        (package embark-package-map)
        (bookmark embark-bookmark-map)
        ;; (region embark-region-map)
        (region my-embark-region-map)
        (sentence embark-sentence-map)
        (paragraph embark-paragraph-map)
        (kill-ring embark-kill-ring-map)
        (heading embark-heading-map)
        (t embark-general-map)))

#+END_EXAMPLE


*** Insert Text in read-only Buffers

Insert text even if the buffer is read-only

#+BEGIN_EXAMPLE elisp

(let ((inhibit-read-only t))
  (insert "\nHello"))

#+END_EXAMPLE


*** Emacs Window Management

#+BEGIN_EXAMPLE elisp

(add-to-list 'display-buffer-alist
             '("\\*eww\\*"
               (display-buffer-reuse-mode-window display-buffer-same-window)))

#+END_EXAMPLE



** TODOs

*** Org-Roam Existing Notes


*** Configure Completion

Configure Capfs:
- cape
- corfu-history
- corfu-quick
- eglot (Clojure)

  See notes: [[https://www.youtube.com/watch?v=ROnceqt3kpE][Using Emacs 74 - Eglot]]

Orderless
Consult
Embark


*** Consult search, ignore case


*** Navigate Mark Ring

Start with these resources.
- [[https://www.youtube.com/watch?v=Dq5UOt63Mms&t=1364s][Efficient Text Selection with Emacs Key Bindings - Emacs Essentials #3 / Remember Your Place with the Mark Ring]]


*** Master Keymaps

[ok] What is full Keymap tree
  https://www.masteringemacs.org/article/mastering-key-bindings-emacs#what-is-a-keymap
  M-x describe-keymap

Fix some key sequences that don't work in all environs


*** Misc

. smartparens, (STRONG) highlight parens
. eval repl (from .clj .edn)

. Emacs Guix
https://emacs-guix.gitlab.io/website/manual/latest/emacs-guix.html#Top


*** Org Journaling


*** Org Presenting


*** Spellcheck Tools and Completions


** Errors


*** Ripgrep is missing from path


*** Hydra mc/mark-next-line double marks cursor

Ie, pressing next selects the next n, instead of the next 1.


*** smartparens open square bracket fails to add closing bracket, when touched by a character
